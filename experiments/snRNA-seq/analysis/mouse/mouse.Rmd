---
title: "Mouse VMH populations"
author: "Alan Rupp"
date: "`r strftime(Sys.time(), '%b %d, %Y')`"
output: pdf_document
geometry: margin=0.5in
---

Analysis of the mouse VMH 10x datasets.

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE,
                      fig.align = "center")
library(tidyverse)
library(Seurat)
library(knitr); library(kableExtra)
options(bitmapType = "cairo")
options(future.globals.maxSize = 3000 * 1024^2)
map(list.files("../../../../tools/dropseq3/R", full.names = TRUE), source)
```

Loading data ...

```{r read}
# read in all 10X data
dirs <- list.dirs(path = '../../data')
dirs <- dirs[str_detect(dirs, "filtered")]

# remove macaque dataset from `dirs`
nhp_dir <- dirs[str_detect(dirs, "NovaA-225")]
dirs <- dirs[!dirs %in% nhp_dir]
rm(nhp_dir)

# extract sample and run info from names
samples <- str_extract(dirs, "(?<=[0-9]\\/)(.+?)(?=\\/outs)")
runs <- str_extract(dirs, "(?<=data\\/)(.+?)(?=\\/)")

# read in data as a list of matrices
mtx <- map(dirs, Read10X)
```

There are `r length(unique(runs))` runs, comprising `r length(samples)` samples and `r format(sum(map_int(mtx, ncol)), big.mark = ",")` total cells.

```{r}
# table of samples and total cells
data.frame(
  "Run" = runs,
  "Sample" = samples,
  "Nuclei" = format(map_int(mtx, ncol), big.mark = ",")
) %>%
  arrange(Run, Sample) %>%
  kable(caption = "Samples") %>%
  kable_styling(full_width = FALSE, position = "left",
                latex_options = "hold_position")
```

\pagebreak

# Quality control
## Keeping high quality genes
I'm keeping only genes expressed in at least 4 cells and present in all `r length(mtx)` samples.

```{r genes-filtering}
print(paste("Starting with", max(map_int(mtx, nrow)), "genes ..."))
mtx <- keep_shared_genes(mtx)
mtx <- remove_unwanted_genes(mtx)
mtx <- remove_low_abundance_genes(mtx)
print(paste("Now", max(map_int(mtx, nrow)), "genes."))
```

## Keeping high quality cells
I'm going to remove any cells that have fewer than 500 genes detected.

```{r filter-cells}
print(paste("Starting with", sum(map_int(mtx, ncol)), "cells ..."))
mtx <- filter_cells(mtx)
mtx <- rename_duplicates(mtx)
print(paste("Now", sum(map_int(mtx, ncol)), "cells."))
```

Continuing with data analysis.

---

```{r create-seurat, include = FALSE}
# combine into Seurat object
srt <- CreateSeuratObject(do.call(cbind, mtx))

# add metadata
srt$Run = rep(runs, times = map_dbl(mtx, ncol))
srt$Sample <- rep(samples, times = map_dbl(mtx, ncol))
rm(mtx, runs, samples)
gc()
```

```{r metadata-colors}
run_colors <- rcartocolor::carto_pal(length(unique(srt$Run)), "Antique")
run_colors <- order_colors(run_colors)
names(run_colors) <- sort(unique(srt$Run))
sample_colors <- rcartocolor::carto_pal(length(unique(srt$Sample)), "Safe")
sample_colors <- order_colors(sample_colors)
names(sample_colors) <- sort(unique(srt$Sample))

# stash in object for later retrieval
srt@misc$run_colors <- run_colors
srt@misc$sample_colors <- sample_colors
```

# Quality control
```{r, fig.width = 2.2, fig.height = 1.9}
fig_cells <- table(srt$Sample, srt$Run) %>%
  as.data.frame() %>%
  filter(Freq != 0) %>%
  rename("Sample" = Var1, "Run" = Var2) %>%
  select(-starts_with("Var")) %>%
  ggplot(aes(x = Sample, y = Freq, fill = Run)) +
  geom_col(color = "black") +
  scale_fill_manual(values = run_colors, name = expression(underline("Run"))) +
  ggtitle("Cells") +
  theme_void() +
  theme(axis.text.x = element_text(color = "black", angle = 90,
                                   hjust = 1, vjust = 0.5, size = 8),
        axis.text.y = element_text(color = "black", size = 7),
        plot.title = element_text(size = 10, hjust = 0.5),
        legend.key.width = unit(0.1, "in"),
        legend.key.height = unit(0.05, "in"))

```

```{r, fig.width = 4, fig.height = 1.9}
plot_metadata <- function(measure, title = NULL) {
  data.frame(
    "metadata" = srt@meta.data[, measure],
    "Sample" = srt$Sample,
    "Run"= srt$Run
    ) %>%
    ggplot(aes(x = Sample, y = metadata, fill = Run)) +
    geom_violin() +
    scale_fill_manual(values = run_colors, name = expression(underline("Run"))) +
    scale_y_continuous(trans = "log2") +
    ggtitle(title) +
    theme_void() +
  theme(axis.text.x = element_text(color = "black", angle = 90,
                                   hjust = 1, vjust = 0.5, size = 8),
        axis.text.y = element_text(color = "black", size = 7),
        strip.text = element_text(size = 10),
        legend.title = element_text(size = 9),
        legend.key.height = unit(0.02, "in"),
        legend.key.width = unit(0.08, "in"),
        plot.title = element_text(hjust = 0.5, size = 10))
}

fig_genes <- plot_metadata("nFeature_RNA", "Genes") +
  theme(legend.position = "none")
fig_umis <- plot_metadata("nCount_RNA", "UMIs")
```

```{r plot-metadata, fig.height = 1.9, fig.width = 4.5}
cowplot::plot_grid(plotlist = list(
  fig_cells + theme(legend.position = "none"), fig_genes, fig_umis),
  ncol = 3, rel_widths = c(1, 1, 1.3))
```

Some of the earlier runs have the lowest genes & UMIs detected). I'll leave them in for now, but this might confound clustering.

\pagebreak

# Identifying cell types
My main goal is simply to identify neurons for downstream analysis, but I'm going to predict cell type for each cell and cluster all cells so we'll have the data in case we want to look at glia.

Pipeline:
1. Normalizing data with `scran` `r packageVersion("scran")` for each run independently
2. Finding variable genes with `Seurat`
3. Scaling variable genes for each sample independently
4. Running PCA on scaled data
5. Choosing PCs from the elbow on the scree plot
6. Projecting into UMAP space

```{r process-all, include = FALSE}
srt <- normalize_data(srt, method = "scran", batch = "Run")
srt <- FindVariableFeatures(srt)
srt <- scale_data(srt, genes = srt@assays$RNA@var.features, groups = "Sample")
srt <- RunPCA(srt, npcs = 100)
srt@reductions$pca@misc$sig_pcs <- knee_test(srt)
srt <- RunUMAP(srt, dims = 1:srt@reductions$pca@misc$sig_pcs)
gc()
```

Results: using `r length(srt@assays$RNA@var.features)` variable genes and `r srt@reductions$pca@misc$sig_pcs` PCs.

```{r dimplot-sample-all, fig.height = 3, fig.width = 4}
DimPlot(srt, group.by = "Sample", cells = sample(Cells(srt), 20000)) +
  scale_color_manual(values = srt@misc$sample_colors) +
  theme_void() +
  theme(legend.text = element_text(size = 7),
        plot.title = element_blank())
```

This looks great, continuing with identifying cell types.

\pagebreak

# Predicting cell types
I'm going to use published scRNA-seq data (from Campbell et al. and Chen et al.) to infer cell types in our dataset. In short, I'll use the top marker genes from each celltype in those dataset to assign a score to each cell in our dataset. Then, I'll cluster our cells and assign celltype membership based on the score, plus whether they are a presumptive doublet (from the `scrublet` package). I'll refer to doublets & unclassifed cells as NA.

```{r}
print("Clustering ...")
```

```{r cluster-all, include = FALSE}
srt <- FindNeighbors(srt, dims = 1:srt@reductions$pca@misc$sig_pcs)
srt <- FindClusters(srt)
```

There are `r length(unique(srt@active.ident))` clusters.

```{r, include = FALSE}
# find cluster markers
srt@misc$markers <- FindAllMarkers(srt, only.pos = TRUE)
cluster_order <- order_clusters(srt, srt@assays$RNA@var.features)
srt@active.ident <- factor(
  srt@active.ident,
  levels = cluster_order,
  labels = 1:length(cluster_order)
)
srt@misc$markers$cluster <- factor(
  srt@misc$markers$cluster,
  levels = cluster_order,
  labels = 1:length(cluster_order)
)
srt$seurat_clusters <- srt@active.ident
```

```{r}
color_options <- map(
  names(wesanderson::wes_palettes),
  ~ as.character(wesanderson::wes_palette(.x))
) %>%
  unlist()

# only keep colors that aren't too light or dark
get_luminance <- function(color) {
  col <- col2rgb(color)
  0.2126*col["red", ] + 0.7152*col["green", ] + 0.0722*col["blue" ,]
}

# cluster similar colors for each class
color_options <- color_options[
  get_luminance(color_options) > 100 & get_luminance(color_options) < 200
]

# skip along colors to get full coverage
color_options <- order_colors(color_options)
skip <- length(color_options)/length(levels(srt@active.ident))
cluster_colors <- color_options[
  round(seq(skip, skip*length(levels(srt@active.ident)), by = skip), 0)
]
names(cluster_colors) <- levels(srt@active.ident)
srt@misc$cluster_colors <- cluster_colors
```

```{r, fig.width = 2.5, fig.height = 2.5}
dim_plot(srt, repel = TRUE, label_size = 2, point_size = 0.4) +
  scale_color_manual(values = srt@misc$cluster_colors)
```

```{r find-celltypes}
print("Predicting cell type membership ...")
markers <- read_csv("../celltypes/markers.csv")
# only keep markers in the Seurat object
markers <- filter(markers, !is.na(Gene))
markers <- filter(markers, Gene %in% rownames(srt))
markers <- filter(markers, !duplicated(Gene))
markers <- as.data.frame(markers) %>% column_to_rownames("Gene")

# get top 100 markers for each cell type
top_markers <- apply(markers, 2, function(x) {
  names(x) = rownames(markers)
  sort(x, decreasing = TRUE)[1:100] %>% names()
})

# scale data for top markers
srt <- scale_data(srt, genes = c(top_markers), groups = "Sample"); gc()

if (ncol(srt) > 10000) {
  cells <- sample(Cells(srt), 10000)
} else {
  cells <- Cells(srt)
}
scaled <- srt@assays$RNA@scale.data[, cells]

# predict celltype by max cumsum for scaled marker genes
get_celltype <- function(cell) {
  scores <- sapply(colnames(top_markers), function(x) {
    max(cumsum(scaled[top_markers[, x], cell]), na.rm = TRUE)  
  })
  if (max(scores, na.rm = TRUE) < 0) {
    "Unclassified"
  } else {
    names(scores)[scores == max(scores)]
  }
}
celltypes <- sapply(cells, get_celltype)

# call celltype by cluster
cluster_table <- table(srt@active.ident[cells], celltypes)
cluster_celltypes <- apply(cluster_table, 1, function(x) {
  if (any(x > sum(x)/2)) {
    names(x)[x == max(x)]
  } else {
    "Mixed"
  }
})
srt$Celltype <- recode(srt@active.ident, !!!cluster_celltypes)
```

```{r}
table(srt$Celltype) %>%
  as.data.frame() %>%
  mutate("Percent" = round(Freq / sum(Freq) * 100, 1)) %>%
  arrange(desc(Percent)) %>%
  rename("Cells" = Var1, "N" = Freq) %>%
  kable(caption = "Cell type breakdown") %>%
  kable_styling(latex_options = "hold_position")
```

```{r, fig.width = 6, fig.height = 3}
srt@active.ident <- factor(srt$Celltype)
cluster_order <- order_clusters(srt, unique(c(top_markers)))
srt@active.ident <- factor(srt@active.ident, levels = cluster_order)

celltype_colors <- c(
  wesanderson::wes_palette("Moonrise1"),
  wesanderson::wes_palette("Moonrise2"),
  wesanderson::wes_palette("Moonrise3")
)

get_luminance <- function(color) {
  col <- col2rgb(color)
  0.2126*col["red", ] + 0.7152*col["green", ] + 0.0722*col["blue" ,]
}

celltype_colors <- celltype_colors[get_luminance(celltype_colors) > 80 &
                                   get_luminance(celltype_colors) < 220]
celltype_colors <- celltype_colors[1:length(levels(srt@active.ident))]
names(celltype_colors) <- levels(srt@active.ident)

cowplot::plot_grid(plotlist = list(
  DimPlot(srt, label = TRUE, cells = sample(Cells(srt), 10000)) +
    scale_color_manual(values = celltype_colors) +
    theme_void() +
    theme(legend.position = "none"),
  table(srt$Sample, srt@active.ident) %>%
    as.data.frame() %>%
    mutate(Var1 = factor(Var1, levels = unique(srt$Sample))) %>%
    group_by(Var1) %>%
    mutate("Percent" = Freq / sum(Freq) * 100) %>%
    ggplot(aes(x = Var1, y = Percent, fill = Var2)) +
    geom_col() +
    xlab(NULL) +
    ylab("% of dataset") +
    scale_y_continuous(expand = c(0, 0)) +
    scale_fill_manual(values = celltype_colors, name = NULL) +
    theme_classic() +
    theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5,
                                     color = "black", size = 8),
          axis.text.y = element_text(size = 7),
          axis.title.y = element_text(size = 8),
          legend.key.width = unit(0.08, "in"),
          legend.key.height = unit(0.04, "in"),
          legend.text = element_text(size = 7))
))
```

Good balance of cell types across all samples.

---

I'm saving the all-cell object as `mouse.rds` and I'll move on to just neuron analysis.

```{r}
saveRDS(srt, "mouse.rds")
```

\pagebreak

# Neurons
There are `r format(sum(srt@active.ident == "Neuron"), big.mark = ",")` neurons. I'll process them separately now to identify neuronal populations.

```{r, include = FALSE}
neurons <- subset(srt, idents = "Neuron")
rm(srt); gc()
```

Pipeline:
1. Finding variable genes with `Seurat`
2. Running `sctransform` with Run as a batch variable.
2. Scaling variable genes (in both RNA and SCT assays) for each sample independently
3. Running PCA on scaled data
4. Choosing PCs from the elbow on the scree plot
5. Projecting into UMAP space

```{r, include = FALSE}
neurons <- FindVariableFeatures(neurons)
neurons <- SCTransform(neurons, conserve.memory = TRUE, batch_var = "Run")
var_genes <- intersect(
  neurons@assays$RNA@var.features, neurons@assays$SCT@var.features
)

# compare RNA and SCT assays for batch effects
DefaultAssay(neurons) <- "RNA"
neurons <- scale_data(neurons, genes = var_genes, groups = "Sample")
neurons <- RunPCA(neurons, npcs = 100)
neurons@reductions$pca@misc$sig_pcs <- knee_test(neurons)
neurons <- RunUMAP(neurons, dims = 1:neurons@reductions$pca@misc$sig_pcs)

umap_object <- neurons[["umap"]]
pca_object <- neurons[["pca"]]

# compare RNA and SCT assays for batch effects
DefaultAssay(neurons) <- "SCT"
neurons <- RunPCA(neurons, npcs = 100)
neurons@reductions$pca@misc$sig_pcs <- knee_test(neurons)
neurons <- RunUMAP(neurons, dims = 1:neurons@reductions$pca@misc$sig_pcs)

gc()
```

Results: Using `r length(neurons@assays$RNA@var.features)` variable genes from `Seurat` found `r length(neurons@assays$SCT@var.features)` from `sctransform`.  The `Seurat` variable features resulted in `r pca_object@misc$sig_pcs` PCs, and the `sctransform` variable genes resulted in `r neurons@reductions$pca@misc$sig_pcs` PCs.

```{r, fig.width = 7, fig.height = 3.2}
plot_umap_samples <- function(umap) {
  df <- bind_cols(as.data.frame(umap), neurons$Sample)
  df <- df[sample(1:nrow(df), 10000), ]
  ggplot(df, aes(x = UMAP_1, y = UMAP_2, color = `...3`)) +
    geom_point(stroke = 0, size = 1) +
    scale_color_manual(values = neurons@misc$sample_colors, name = NULL) +
    theme_void() +
    theme(legend.text = element_text(size = 7),
          plot.title = element_text(size = 10, hjust = 0.5))
}

cowplot::plot_grid(plotlist = list(
  plot_umap_samples(umap_object@cell.embeddings) + ggtitle("RNA"),
  plot_umap_samples(neurons@reductions$umap@cell.embeddings) + ggtitle("SCT")
))
```

The **RNA** assay looks better, cells are more "clumped", even across samples, making it more likely to find clusters.

```{r, include = FALSE}
DefaultAssay(neurons) <- "RNA"
neurons[["pca"]] <- pca_object
neurons[["umap"]] <- umap_object
rm(umap_object, pca_object)
gc()
```

\pagebreak

# Removing doublets

Sometimes neuron/glia doublets make it through this filtering step. To detect doublets, I'm going to run WGCNA on the genes that are highly loaded (>2 SD) onto any of the PCs I used for dimension reduction. Any cells that load highly on gene modules that are overrepresented for glia classes will be removed.

```{r wgcna, include = FALSE}
print("Running WGCNA ...")
# choose variable genes
sig_pcs <- neurons@reductions$pca@misc$sig_pcs
var_genes <- apply(
  neurons@reductions$pca@feature.loadings[, 1:sig_pcs], 2, function(x) {
    scaled = scale(x)
    rownames(neurons@reductions$pca@feature.loadings)[abs(scaled) > 2]
  }
) %>%
  unlist() %>%
  unique()

# find WGCNA modules
library(WGCNA)
sft <- pickSoftThreshold(
  Matrix::t(neurons@assays$RNA@data[var_genes, ]),
  networkType = "signed"
)
softPower <- sft$fitIndices$Power[sft$fitIndices[,"SFT.R.sq"] > 0.8][1]

net <- blockwiseModules(
  Matrix::t(neurons@assays$RNA@data[var_genes, ]),
  power = softPower
)
```

WGCNA identifies `r length(unique(net$colors))` module from the `r length(var_genes)` genes, using a soft power threshold of `r softPower`.

```{r}
print("Calculating celltype enrichment of each module with hypergeometric test (with BH adjustment) ...")
# find enrichment of modules by celltype
genes_in_both <- intersect(unique(c(top_markers)), var_genes)
enrichment_test <- function(module) {
  module_genes <- intersect(var_genes[net$colors == module], genes_in_both)
  p <- apply(top_markers, 2, function(x) {
    phyper(q = length(intersect(module_genes, x)),
           m = length(genes_in_both),
           n = length(x),
           k = length(module_genes),
           lower.tail = FALSE)
    })
  p.adjust(p, method = "BH")
}
modules <- unique(net$colors)
enrichment <- sapply(modules, enrichment_test)

celltype_modules <- apply(enrichment, 2, function(x) {
  if (any(x < 0.05)) {
    paste(names(x)[x < 0.05], collapse = ",")
  } else {
    NULL
  }
}) %>%
  unlist()
```

`r sum(enrichment < 0.05)` modules are associated with specific cell types, suggesting that no glia made it through the first filtering.


```{r, include = FALSE}
rm(sft, softPower, net, genes_in_both, enrichment_test, modules, enrichment,
   celltype_modules)
gc()
```


\pagebreak

# Clustering neurons

To cluster, I'll start with standard Louvain clustering from the kNN graph. With `k` set at 20, I'll vary the `resolution` parameter to optimize mean silhouette width.

```{r}
resolutions <- seq(0.2, 2, by = 0.2)
print(paste("Finding clusters for resolutions", paste(resolutions, collapse = ", "), "..."))
```

```{r, include = FALSE}
neurons <- FindNeighbors(neurons, dims = 1:sig_pcs)

clusters <- map_dfc(
  resolutions,
  ~ FindClusters(neurons, resolution = .x)@active.ident
)
gc()
# get dissimilarity matrix
cells <- sample(Cells(neurons), 10000)
sig_pcs <- neurons@reductions$pca@misc$sig_pcs
distances <- cluster::daisy(
  neurons@reductions$pca@cell.embeddings[cells, 1:sig_pcs]
)
gc()

# calculate silhouette width for each clustering
mean_widths <- apply(clusters[match(cells, Cells(neurons)), ], 2, function(x) {
  silhouette_object <- cluster::silhouette(as.numeric(x), distances)
  summary(silhouette_object)[["avg.width"]]
})

# choose best resolution based on max mean silhoutte width
best_resolution <- resolutions[mean_widths == max(mean_widths)]

# add clustering to official ident slot
neurons@active.ident <- clusters[, resolutions == best_resolution][[1]]

# remove unnecessary object
rm(resolutions, clusters, sig_pcs, distances, mean_widths); gc()
```

Using resolution `r best_resolution`, there are `r length(unique(neurons@active.ident))` populations.

\pagebreak

# Neuron markers
I'll now find markers to name the clusters. I'll use both `CELLEX` and `Seurat`.

```{r, include = FALSE}
# cellex
neurons@misc$cellex <- cellex(
  as.data.frame(as.matrix(neurons@assays$RNA@counts)),
  neurons@active.ident  
)
neurons@misc$cellex <- neurons@misc$cellex[, levels(neurons@active.ident)]

# Seurat
neurons@misc$markers <- FindAllMarkers(neurons, only.pos = TRUE)
```

```{r order-neurons}
print("Reordering clusters based on similarity ...")
# recode based on similarity
print(paste("Using the top", nrow(neurons@misc$cellex), "marker genes."))
neurons <- scale_data(neurons, groups = "Sample")
cluster_order <- order_clusters(neurons, rownames(neurons@misc$cellex))

neurons@active.ident <- factor(neurons@active.ident, levels = cluster_order)
neurons@misc$cellex <- neurons@misc$cellex[, cluster_order]
neurons$neuron_clusters <- neurons@active.ident
```

```{r, fig.width = 3, fig.height = 3}
wes_colors <- sapply(names(wesanderson::wes_palettes), wesanderson::wes_palette)
wes_colors <- unlist(wes_colors)
wes_colors <- wes_colors[!duplicated(wes_colors)]

get_luminance <- function(color) {
  col <- col2rgb(color)
  0.2126*col["red", ] + 0.7152*col["green", ] + 0.0722*col["blue" ,]
}
wes_colors <- wes_colors[get_luminance(wes_colors) > 80 &
                         get_luminance(wes_colors) < 220]
cluster_colors <- wes_colors[1:length(levels(neurons@active.ident))]
cluster_colors <- order_colors(cluster_colors)
names(cluster_colors) <- levels(neurons@active.ident)
neurons@misc$cluster_colors <- cluster_colors

dim_plot(neurons, repel = TRUE, point_size = 0.2) +
  scale_color_manual(values = neurons@misc$cluster_colors) +
  theme_void() +
  theme(legend.position = "none")
```

---

Saving the `neurons` Seurat object as `neurons.rds`

```{r}
saveRDS(neurons, "neurons.rds")
```

\pagebreak

# Identifying VMH neurons
*Fezf1* and *Nr5a1* are VMH marker genes.

```{r, fig.width = 1.5, fig.height = 3}
data.frame(
  "cell" = colnames(neurons),
  "UMAP1" = neurons@reductions$umap@cell.embeddings[,1],
  "UMAP2" = neurons@reductions$umap@cell.embeddings[,2],
  "Nr5a1" = neurons@assays$RNA@data["Nr5a1", ],
  "Fezf1" = neurons@assays$RNA@data["Fezf1", ]
) %>%
  sample_n(5000) %>%
  gather(-cell, -UMAP1, -UMAP2, key = "gene", value = "expr") %>%
  ggplot(aes(x = UMAP1, y = UMAP2, color = expr)) +
  geom_point(stroke = 0, size = 1) +
  scale_color_gradient(low = "gray90", high = "navyblue",
                       name = "Normalized\nexpression") +
  theme_void() +
  facet_wrap(~gene, ncol = 1) +
  theme(legend.position = "bottom", legend.direction = "horizontal",
        legend.title = element_text(size = 7),
        legend.text = element_text(size = 7),
        legend.key.height = unit(0.03, "in"),
        legend.key.width = unit(0.15, "in"))
```

It seems clear there's a distinct lobe that corresponds to the VMH populations, but I'll confirm this with the *Nr5a1* TRAP-seq.

```{r, fig.width = 1.5, fig.height = 1.5}
print("Reading in Nr5a1-Cre TRAP-seq data ...")
sf1 <- read_csv("../../../TRAP-seq/VMH_Nr5a1/results.csv")
```

The *Nr5a1-Cre* TRAP-seq dataset has `r sum(sf1$P < 0.05 & sf1$Enrichment > 0, na.rm = TRUE)` enriched genes:

```{r, fig.width = 2, fig.height = 2}
ggplot(sf1, aes(x = Bead, y = Enrichment, color = P < 0.05)) +
  geom_hline(aes(yintercept = 0)) +
  geom_point(alpha = 0.4, stroke = 0) +
  scale_x_continuous(trans = "log2", limits = c(1, NA), expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0)) +
  scale_color_manual(values = c("gray", "red4"), guide = FALSE) +
  geom_text_repel(data = filter(sf1, Gene %in% c("Nr5a1", "Fezf1")),
            aes(label = Gene), show.legend = FALSE, size = 3) +
  theme_classic() +
  xlab("Expression (CPM)") +
  ylab(expression("Enrichment (log"[2]*" Bead/Sup)")) +
  coord_cartesian(ylim = c(0, NA)) +
  theme(legend.position = "top",
        legend.direction = "horizontal",
        axis.title = element_text(size = 7),
        axis.text = element_text(color = "black", size = 6)) +
  annotate("label", x = 2, y = 5.3, hjust = 0,
           label = expression(italic("P")*" < 0.05"), color = "red4",
           size = 2)
```

```{r}
# define snRNA-seq VMH clusters as those with > 0.2 scaled expression of either
# Nr5a1 or Fezf1
marker_clusters <- cluster_means(neurons, c("Nr5a1", "Fezf1"))
marker_clusters <- names(marker_clusters)[
  apply(marker_clusters, 2, function(x) any(x > 0.2))
]
```

To see how well the TRAP corresponds to the snRNA-seq, I'll make a pseudo-bulk dataset from the snRNA-seq by Sample to perform "pseudo-TRAP" on the presumptive VMH populations (`r paste(marker_clusters, collapse = ", ")`) vs. the non-VMH populations (including glia).

```{r}
print("Running pseudo-TRAP with DESeq2 ...")
```

```{r, include = FALSE}
# stashing neuron cluster IDs and loading full dataset
neuron_clusters <- neurons@active.ident
rm(neurons); gc()
srt <- readRDS("mouse.rds")
mtx <- srt@assays$RNA@counts

# make pseudo TRAP from the snRNA-seq
metadata <- data.frame(
  "Cells" = rep(c("Bead", "Sup"), length(unique(srt$Sample))),
  "Sample" = rep(unique(srt$Sample), each = 2)
)
bead_cells <- names(neuron_clusters)[neuron_clusters %in% marker_clusters]
sup_cells <- union(
  Cells(srt)[!Cells(srt) %in% names(neuron_clusters)],
  names(neuron_clusters)[!neuron_clusters %in% marker_clusters]
)
counts <- apply(metadata, 1, function(x) {
  tx_cells <- switch(
    as.character(x["Cells"][[1]]), "Bead" = bead_cells, "Sup" = sup_cells
  )
  sample_cells <- Cells(srt)[srt$Sample == x["Sample"]]
  Matrix::rowSums(mtx[, intersect(tx_cells, sample_cells)])
})

rm(srt); gc()

# run DESeq2 to detect enriched genes
dds <- DESeq2::DESeqDataSetFromMatrix(
  counts, metadata, ~ Sample + Cells
  ) %>%
  DESeq2::DESeq()
pseudo_trap <- DESeq2::results(dds, contrast = c("Cells", "Bead", "Sup"))
pseudo_trap <- as.data.frame(pseudo_trap) %>% rownames_to_column("Gene")
cpm <- DESeq2::fpm(dds)
cpm_cells <- map_dfc(c("Bead", "Sup"), ~ rowMeans(cpm[, metadata$Cells == .x])) %>%
  set_names(c("Bead", "Sup"))
cpm_cells$Gene <- rownames(cpm)
pseudo_trap <- inner_join(cpm_cells, pseudo_trap, by = "Gene") %>%
  select(Gene, Bead, Sup, log2FoldChange, padj) %>%
  rename("Enrichment" = log2FoldChange, "P" = padj)

write.csv(pseudo_trap, "pseudo_trap.csv", row.names = FALSE, na = "")
```

There are `r sum(pseudo_trap$padj < 0.05 & pseudo_trap$log2FoldChange > 0, na.rm = TRUE)` genes that are detected as enriched in the presumptive VMH by pseudo-TRAP:

```{r, fig.width = 2, fig.height = 2}
ggplot(pseudo_trap, aes(x = Bead, y = Enrichment, color = P < 0.05)) +
  geom_hline(aes(yintercept = 0)) +
  geom_point(alpha = 0.4, stroke = 0) +
  scale_x_continuous(trans = "log2", limits = c(1, NA), expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0)) +
  scale_color_manual(values = c("gray", "red4"), guide = FALSE) +
  geom_text_repel(data = filter(pseudo_trap, Gene %in% c("Nr5a1", "Fezf1")),
            aes(label = Gene), show.legend = FALSE, size = 3) +
  theme_classic() +
  xlab("Expression (CPM)") +
  ylab(expression("Enrichment (log"[2]*" Bead/Sup)")) +
  coord_cartesian(ylim = c(0, NA)) +
  theme(legend.position = "top",
        legend.direction = "horizontal",
        axis.title = element_text(size = 7),
        axis.text = element_text(color = "black", size = 6)) +
  annotate("label", x = 2, y = 3.5, hjust = 0,
           label = expression(italic("P")*" < 0.05"), color = "red4",
           size = 2)
```

\pagebreak

## Comparing TRAP and pseudo-TRAP

There are `r length(intersect(filter(sf1, P < 0.05 & Enrichment > 0)$Gene, filter(pseudo_trap, padj < 0.05 & log2FoldChange > 0)$Gene))` genes that are enriched in the presumptive VMH in both datasets (`r round(sum(filter(sf1, Enrichment > 0 & P < 0.05)$Gene %in% filter(pseudo_trap, padj < 0.05 & log2FoldChange > 0)$Gene)/length(filter(sf1, Enrichment > 0 & P < 0.05)$Gene)*100, 1)`% of the *Nr5a1-Cre* TRAP and `r round(sum(filter(pseudo_trap, log2FoldChange > 0 & padj < 0.05)$Gene %in% filter(sf1, P < 0.05 & Enrichment > 0)$Gene)/length(filter(pseudo_trap, log2FoldChange > 0 & padj < 0.05)$Gene)*100, 1)`% of the snRNA-seq pseudo-TRAP enriched genes).

```{r}
trap_enriched <- filter(sf1, Enrichment > 0 & P < 0.05)$Gene
ptrap_enriched <- filter(pseudo_trap, log2FoldChange > 0 & padj < 0.05)$Gene
common <- intersect(trap_enriched, ptrap_enriched)
trap_only <- trap_enriched[!trap_enriched %in% ptrap_enriched]
ptrap_only <- ptrap_enriched[!ptrap_enriched %in% trap_enriched]
```

To determine if there's a biological or technical difference between these datasets, I'll compare the expression levels, classes, and GO terms associated with either genes enriched in both (`r length(common)` genes), genes specific to TRAP (`r length(trap_only)` genes), or genes specific to pseudo-TRAP (`r length(ptrap_only)`).

### Expression level

```{r}
inner_join(pseudo_trap, sf1, by = "Gene") %>%
  mutate("Class" = case_when(
    Gene %in% common ~ "Common",
    Gene %in% trap_only ~ "TRAP",
    Gene %in% ptrap_only ~ "pseudo-TRAP"
  )) %>%
  filter(!is.na(Class)) %>%
  select(Gene, Class, Bead.x, Bead.y) %>%
  pivot_longer(starts_with("Bead"), names_to = "Dataset", values_to = "CPM") %>%
  mutate("Dataset" = factor(Dataset, levels = c("Bead.y", "Bead.x"),
                            labels = c("TRAP dataset",
                                       "pseudo-TRAP dataset"))) %>%
  mutate(Class = factor(Class, levels = c("Common", "TRAP", "pseudo-TRAP"))) %>%
  ggplot(aes(x = log2(CPM+1), y = fct_rev(Class))) +
  ggridges::geom_density_ridges(aes(fill = Class), show.legend = FALSE) +
  geom_vline(aes(xintercept = 0)) +
  xlab(expression("Bead expression (log"[2]*"CPM)")) +
  ylab("Enriched geneset") +
  theme_classic() +
  facet_wrap(~Dataset) +
  theme(axis.text.x = element_text(color = "black"),
        axis.text.y = element_text(color = "black"),
        strip.background = element_blank())
```

This shows that genes common to both datasets tend to be highly expressed, whereas genes specifically enriched in either TRAP or pseudo-TRAP tend to be highly expressed in that dataset, but lowly expressed in the other.

### Gene class
I'll use a list of annotated genes by function to determine if any particular class of genes is more or less likely to be found in any given dataset using a hypergeometric test.

```{r}
annotation <- read_csv("../../../../tools/dropseq3/data/annotation.csv")
annotation <- filter(annotation, gene %in% c(common, trap_only, ptrap_only))

hyper_test <- function(geneset) {
  # q = number of white balls drawn from urn
  # m = number of white balls in urn
  # n = number of black balls in urn
  # k = number of balls drawn from urn
  sapply(colnames(annotation[, 2:ncol(annotation)]), function(x) {
    phyper(
      q = sum(filter(annotation, gene %in% geneset) %>% pull(x)),
      m = sum(annotation$receptor),
      n = nrow(annotation) - sum(annotation[, x]),
      k = length(geneset),
    lower.tail = FALSE)
  })
}

results <- sapply(c("common", "trap_only", "ptrap_only"), function(x) {
  hyper_test(get(x))
}) %>%
  as.data.frame() %>%
  rownames_to_column("Annotation") %>%
  pivot_longer(-Annotation, names_to = "Geneset", values_to = "P") %>%
  mutate(FDR = p.adjust(P, method = "BH")) %>%
  mutate(Geneset = factor(Geneset,
                          levels = c("common", "trap_only", "ptrap_only"),
                          labels = c("Common", "TRAP", "pseudo-TRAP")))

ggplot(results, aes(x = Geneset, y = Annotation, fill = -log10(FDR))) +
  geom_tile() +
  scale_fill_gradient(low = "gray90", high = "red4") +
  xlab(NULL) +
  ylab(NULL) +
  theme_void() +
  theme(axis.text.x = element_text(color = "black"),
        axis.text.y = element_text(color = "black", hjust = 1),
        legend.key.width = unit(0.02, "in"))
```

Intriguingly, receptors are highly enriched in both TRAP datasets, but not in either separately, suggesting that both datasets are accurately capturing all the receptors in the VMH. On the flip-side, transcription factors are enriched in all 3 datasets, suggesting that transcription factor enrichment is highly variable between TRAP and pseudo-TRAP. This could reflect a tissue prep difference?

```{r, include = FALSE}
gc()
```

\pagebreak

# Identifying VMH neurons
I'll use the *Nr5a1-Cre* TRAP-seq enriched genes that are expressed at least 10 CPM and log2 enriched at least 1 to identify VMH neurons in the snRNA-seq.

```{r}
neurons <- readRDS("neurons.rds")
sf1 <- sf1 %>% filter(
  Bead > 10 & P < 0.05 & Enrichment > 1 &
    Gene %in% rownames(neurons@assays$RNA@scale.data)[
      rowSums(is.na(neurons@assays$RNA@scale.data)) == 0]
)
```

That corresponds to `r nrow(sf1)` genes:

```{r, fig.width = 3.3, fig.height = 2}
# Figure 1e
df <- neurons@assays$RNA@scale.data[sf1$Gene, ] %>%
  Matrix::t() %>%
  as.matrix() %>%
  as.data.frame() %>%
  bind_cols(., data.frame(
    "cluster" = neurons@active.ident),
    "cell" = names(neurons@active.ident)
    ) %>%
  gather(-cluster, -cell, key = "gene", value = "expr") %>%
  mutate(gene = factor(gene, levels = sf1$Gene)) %>%
  arrange(cluster) %>%
  mutate(cell = factor(cell, levels = unique(cell))) %>%
  mutate(expr = ifelse(expr > 3, 3, ifelse(expr < -1, -1, expr)))

p <- ggplot(df, aes(x = cell, y = fct_rev(gene), fill = expr)) +
  geom_tile() +
  scale_fill_gradient2(high = "navyblue",
                      name = "Scaled\nexpression",
                      breaks = seq(-1, 3),
                      labels = c("<-1", 0, 1, 2, ">3")) +
  ggtitle(expression(italic("Nr5a1")*" TRAP-enriched genes")) +
  theme_void() +
  theme(legend.position = "bottom", legend.direction = "horizontal",
        legend.key.height = unit(0.03, "in"),
        legend.text = element_text(size = 6),
        legend.title = element_text(size = 6),
        panel.border = element_rect(fill = NA, color = "black"),
        plot.title = element_text(size = 8, hjust = 0.5))

# add cluster color bars
cluster_table <- df %>% group_by(cluster) %>% count() %>%
  mutate(n = n / length(sf1$Gene)) %>% ungroup() %>%
  mutate("end" = cumsum(n)) %>%
  mutate("start" = lag(end, default = 0) + 1)
for (i in 1:nrow(cluster_table)) {
  p <- p + annotate(
    "rect",
    xmin = cluster_table[i, ]$start,
    xmax = cluster_table[i, ]$end,
    ymin = -length(sf1$Gene)*0.03,
    ymax = 0,
    fill = cluster_colors[i],
    color = "black"
  ) +
    annotate(
      "text",
      x = (cluster_table[i, ]$start + cluster_table[i, ]$end)/2,
      y = -length(marker_genes)*0.015,
      label = cluster_table[i, ]$cluster,
      size = 2
    )
}
# add annotation rect of VMH populations
p <- p + annotate(
  "rect",
  xmin = min(filter(cluster_table, cluster %in% 16:21)$start),
  xmax = max(filter(cluster_table, cluster %in% 16:21)$end),
  ymin = -length(sf1$Gene)*0.03,
  ymax = length(sf1$Gene) + 0.5,
  fill = NA, color = "gray", size = 1
) + annotate(
  "rect",
  xmin = min(filter(cluster_table, cluster %in% 43:44)$start),
  xmax = max(filter(cluster_table, cluster %in% 43:44)$end),
  ymin = -length(sf1$Gene)*0.03,
  ymax = length(sf1$Gene) + 0.5,
  fill = NA, color = "gray", size = 1
)

p


```

I'll use PCA to reduce these enriched genes into a single score for each cell.

```{r}
sf1_score <- eigengene(neurons, sf1$Gene)
```

```{r, fig.width = 1.5, fig.height = 1.6}
# Figure 1f
data.frame(
    "UMAP1" = neurons@reductions$umap@cell.embeddings[,1],
    "UMAP2" = neurons@reductions$umap@cell.embeddings[,2],
    "Sf1" = sf1_score
    ) %>%
    mutate(Sf1 = ifelse(Sf1 > 10, 10, ifelse(Sf1 < -10, -10, Sf1))) %>%
    ggplot(aes(x = UMAP1, y = UMAP2, color = Sf1)) +
    geom_point(stroke = 0, size = 0.5) +
    theme_void() +
    scale_color_gradient2(name = "TRAP\nloading",
                          labels = c("<-10", -5, 0, 5, ">10"),
                          mid = "gray95") +
  theme(legend.position = "top", legend.direction = "horizontal",
        legend.key.height = unit(0.03, "in"),
        legend.key.width = unit(0.15, "in"),
        legend.text = element_text(size = 6),
        legend.title = element_text(size = 6))
```

This is also consistent with cells that have the most the *Fezf* and *Nr5a1* expression.

## Calling VMH populations
To do this in an unbiased way, I'll call VMH neurons as clusters that are VGLUT2 (*Slc17a6*)-positive, *Gad1*-negative, either *Fezf1*- or *Nr5a1*-positive, and have a positive *Nr5a1* TRAP score.

```{r}
marker_means <- cluster_means(neurons, c("Slc17a6", "Gad1", "Fezf1", "Nr5a1"))
vmh_scores <- map_dbl(
  sort(unique(neurons@active.ident)),
  ~ median(sf1_score[neurons@active.ident == .x])
)
```

```{r}
vmh_clusters <- colnames(marker_means)[
  marker_means["Slc17a6", ] > 0 & marker_means["Gad1", ] < 0 &
  (marker_means["Fezf1", ] > 0 | marker_means["Nr5a1", ] > 0) &
    vmh_scores > 0
]
```

```{r, fig.width = 7.5, fig.height = 0.9}
marker_means["TRAP", ] <- vmh_scores

marker_means %>% t() %>% as.data.frame() %>%
  rownames_to_column("cluster") %>%
  mutate_if(is.numeric, ~ .x > 0) %>%
  rename("Glutamatergic" = Slc17a6) %>%
  mutate(Gad1 = !Gad1) %>%
  rename("not GABAergic" = Gad1) %>%
  gather(-cluster, key = "measure", value = "result") %>%
  mutate(measure = factor(measure, levels = c(
    "Nr5a1", "Fezf1", "Glutamatergic", "not GABAergic", "TRAP"
  ))) %>%
  mutate(cluster = factor(cluster, levels = colnames(marker_means))) %>%
  ggplot(aes(x = cluster, y = fct_rev(measure), fill = result)) +
  geom_tile(color = "gray20", show.legend = FALSE) +
  scale_fill_manual(values = c("gray90", "blue4")) +
  theme_void() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5),
        axis.text.y = element_text(hjust = 1, vjust = 0.5))

```

This correponds to the UMAP clusters of:

```{r, fig.width = 2.5, fig.height = 2.5}
data.frame(
  "VMH" = neurons@active.ident %in% vmh_clusters,
  "UMAP1" = neurons@reductions$umap@cell.embeddings[,1],
  "UMAP2" = neurons@reductions$umap@cell.embeddings[,2]
) %>%
  ggplot(aes(x = UMAP1, y = UMAP2, color = VMH)) +
  geom_point(stroke = 0, size = 1, show.legend = FALSE) +
  scale_color_manual(values = c("gray90", "blue4")) +
  theme_void()
```

This confirms that clusters `r paste(vmh_clusters, collapse = ", ")` represent the VMH. That is `r format(sum(neurons@active.ident %in% vmh_clusters), big.mark = ",")` neurons, `r round(sum(neurons@active.ident %in% vmh_clusters)/length(neurons@active.ident), 2)*100`% of the total.

```{r, include = FALSE}
vmh <- subset(neurons, idents = vmh_clusters)
rm(cluster_names, marker_means, mean_values,
   neurons, sf1, cluster_colors, cluster_order, sf1_score,
   vmh_clusters, vmh_scores)
gc()
```

\pagebreak

# Removing outlier cells

Some cells that clustered with VMH populations are not part of the broader VMH in UMAP space. These are likely mis-clustering contaminants. I'll remove them using `DBSCAN` before proceeding with subclustering VMH.

```{r, fig.width = 3, fig.height = 2.5}
DimPlot(vmh) +
  scale_color_manual(values = vmh@misc$cluster_colors) +
  theme_void()
```

```{r}
neuron_umap <- data.frame(
  "UMAP1" = vmh@reductions$umap@cell.embeddings[, 1],
  "UMAP2" = vmh@reductions$umap@cell.embeddings[, 2]
)

# running DBSCAN to find outliers in UMAP space
dbscan::kNNdistplot(neuron_umap)
title("Choosing episilon")
abline(a = 0.25, b = 0)

clusters <- dbscan::dbscan(neuron_umap, eps = 0.25)
```

`DBSCAN` finds `r length(unique(clusters$cluster)[unique(clusters$cluster) != 0])` clusters, not counting 1 outlier cluster (in dark green):

```{r, fig.width = 2, fig.height = 2}
neuron_umap %>%
  mutate(k = clusters$cluster) %>%
  ggplot(aes(x = UMAP1, y = UMAP2, color = factor(k))) +
  geom_point(show.legend = FALSE, stroke = 0, size = 0.8) +
  scale_color_manual(values = wesanderson::wes_palette("Chevalier1")) +
  theme_void()
```

`r sum(clusters$cluster[clusters$cluster == 1])` of the neurons fall into the largest cluster (`r round(sum(clusters$cluster[clusters$cluster == 1])/length(clusters$cluster)*100, 1)`% of the total). I'll just keep these for future processing.

I'll save the outlier cells as `vmh_outliers.rds` in case I want them in the future.

```{r}
inliers <- Cells(vmh)[clusters$cluster == 1]
outliers <- Cells(vmh)[clusters$cluster != 1]
saveRDS(subset(vmh, cells = outliers), "vmh_outliers.rds")
vmh <- subset(vmh, cells = inliers)
```

\pagebreak

# Preprocessing VMH neurons

There are `r format(ncol(vmh), big.mark = ",")` VMH neurons. I'll process them separately now to identify neuronal populations.

Pipeline:
1. Finding variable genes with `Seurat`
2. Running `sctransform` with Run as a batch variable.
2. Scaling variable genes (in both RNA and SCT assays) for each sample independently
3. Running PCA on scaled data
4. Choosing PCs from the elbow on the scree plot
5. Projecting into UMAP space

```{r, include = FALSE}
vmh <- FindVariableFeatures(vmh)
vmh <- SCTransform(vmh, conserve.memory = TRUE, batch_var = "Run")
var_genes <- intersect(
  vmh@assays$RNA@var.features, vmh@assays$SCT@var.features
)

# compare RNA and SCT assays for batch effects
DefaultAssay(vmh) <- "RNA"
vmh <- scale_data(vmh, genes = var_genes, groups = "Sample")
vmh <- RunPCA(vmh, npcs = 100)
vmh@reductions$pca@misc$sig_pcs <- knee_test(vmh)
vmh <- RunUMAP(vmh, dims = 1:vmh@reductions$pca@misc$sig_pcs)

umap_object <- vmh[["umap"]]
pca_object <- vmh[["pca"]]

# compare RNA and SCT assays for batch effects
DefaultAssay(vmh) <- "SCT"
vmh <- RunPCA(vmh, npcs = 100)
vmh@reductions$pca@misc$sig_pcs <- knee_test(vmh)
vmh <- RunUMAP(vmh, dims = 1:vmh@reductions$pca@misc$sig_pcs)

gc()
```

Results: Using `r length(neurons@assays$RNA@var.features)` variable genes from `Seurat` found `r length(neurons@assays$SCT@var.features)` from `sctransform`.  The `Seurat` variable features resulted in `r pca_object@misc$sig_pcs` PCs, and the `sctransform` variable genes resulted in `r neurons@reductions$pca@misc$sig_pcs` PCs.

```{r, fig.width = 7, fig.height = 3.2}
plot_umap_samples <- function(umap) {
  df <- bind_cols(as.data.frame(umap), vmh$Sample)
  ggplot(df, aes(x = UMAP_1, y = UMAP_2, color = `...3`)) +
    geom_point(stroke = 0, size = 1) +
    scale_color_manual(values = vmh@misc$sample_colors, name = NULL) +
    theme_void() +
    theme(legend.text = element_text(size = 7),
          plot.title = element_text(size = 10, hjust = 0.5))
}

cowplot::plot_grid(plotlist = list(
  plot_umap_samples(umap_object@cell.embeddings) + ggtitle("RNA"),
  plot_umap_samples(vmh@reductions$umap@cell.embeddings) + ggtitle("SCT")
))
```

The **RNA** assay looks better, cells are more "clumped", even across samples, making it more likely to find clusters.

```{r, include = FALSE}
DefaultAssay(vmh) <- "RNA"
vmh[["pca"]] <- pca_object
vmh[["umap"]] <- umap_object
rm(umap_object, pca_object)
gc()
```

\pagebreak

# Rabies infection

Before I proceed with clustering, 2 samples (Sample_C541 and Sample_C542) were injected with rabies to test whether we could detect retrograde infected cells prior to snRNA-seq. I pulled a published bulk RNA-seq dataset (SRP061600) of rabies infection in the CNS and found differentially expressed genes (upregulated with rabies). I'll look for gene signatures of rabies in this dataset to make sure that rabies is not artificially altering the transcriptome of some cells.

```{r}
rabies <- read_csv("SRP061600/results.csv")
rabies_genes <- rabies %>%
  filter(padj < 0.05 & log2FoldChange > 0) %>%
  filter(gene_biotype == "protein_coding") %>%
  arrange(desc(log2FoldChange)) %>%
  filter(gene_name %in% rownames(vmh)) %>%
  filter(gene_name %in% rownames(vmh)[
    !apply(vmh@assays$RNA@scale.data, 1, function(x) any(is.na(x)))
    ]) %>%
  pull(gene_name)
```

This dataset has `r length(rabies_genes)` genes that are upregulated with rabies infection. I'll now find the eigengene associated with those upregulated genes in each cell:

```{r, fig.width = 3, fig.height = 3}
rabies_score <- eigengene(vmh, rabies_genes)

data.frame(
  "UMAP1" = vmh@reductions$umap@cell.embeddings[, 1],
  "UMAP2" = vmh@reductions$umap@cell.embeddings[, 2],
  "score" = rabies_score
) %>%
  ggplot(aes(x = UMAP1, y = UMAP2, color = score)) +
  geom_point(stroke = 0, size = 0.8) +
  scale_color_gradient2(low = "#A16928", mid = "#edeac2", high = "#2887a1",
                        name = "Rabies\nsimilarity") +
  theme_void() +
  theme(legend.key.width = unit(0.02, "in"),
        legend.text = element_text(size = 6),
        legend.title = element_text(size = 7))
```

From the cells that seem to have a strong rabies signature, they don't seem to be clustered in space. I'll leave them all in because it shouldn't affect clustering.

\pagebreak

# IEG scoring

Lastly, some neurons have a robust response to the isolation protocol and will dramatically upregulate immediate early genes. I'm going to remove any cells that appear to have a strong IEG signature localized in one area.

```{r, fig.width = 2.5, fig.height = 2.5}
iegs <- readxl::read_xlsx("../../../../tools/dropseq3/data/tyssowski_iegs.xlsx")
iegs <- filter(iegs, `Gene ID` %in% rownames(vmh)[
  !apply(vmh@assays$RNA@scale.data, 1, function(x) any(is.na(x)))
])
print(paste("Scoring cells based on", nrow(iegs), "rapid IEGs ..."))
ieg_score <- eigengene(vmh, iegs$`Gene ID`)

data.frame(
  "UMAP1" = vmh@reductions$umap@cell.embeddings[, 1],
  "UMAP2" = vmh@reductions$umap@cell.embeddings[, 2],
  "score" = ieg_score
) %>%
  ggplot(aes(x = UMAP1, y = UMAP2, color = score)) +
  geom_point(stroke = 0, size = 0.8) +
  scale_color_gradient2(low = "#A16928", mid = "#edeac2", high = "#2887a1",
                        name = "IEG\nsignature") +
  theme_void() +
  theme(legend.key.width = unit(0.02, "in"),
        legend.text = element_text(size = 6),
        legend.title = element_text(size = 7))
```

```{r}
ieg_threshold <- 4
activated <- Cells(vmh)[ieg_score >= ieg_threshold]
baseline <- Cells(vmh)[ieg_score < ieg_threshold]

```

There's definitely a clump of cells with a high activation score. I'll remove these to make sure they don't confound analysis. Using an IEG score threshold of `r ieg_threshold`, there are `r length(activated)` cells that I'll remove (`r round(length(activated)/ncol(vmh)*100, 1)`% of the total).

I'll save the activated cells as `vmh_activated.rds` in case I want to look at them in the future.

```{r, include = FALSE}
saveRDS(subset(vmh, cells = activated), "vmh_activated.rds")
vmh <- subset(vmh, cells = baseline)
rm(iegs, ieg_score, ieg_threshold, activated, baseline)
gc()
```

\pagebreak

# Preprocessing VMH neurons (again)

Because I removed those activated cells, I'll re-process the remaining `r ncol(vmh)` VMH neurons.

Pipeline:
1. Finding variable genes with `Seurat`
2. Running `sctransform` with Run as a batch variable.
2. Scaling variable genes (in both RNA and SCT assays) for each sample independently
3. Running PCA on scaled data
4. Choosing PCs from the elbow on the scree plot
5. Projecting into UMAP space

```{r, include = FALSE}
vmh <- FindVariableFeatures(vmh)
vmh <- SCTransform(vmh, conserve.memory = TRUE, batch_var = "Run")
var_genes <- intersect(
  vmh@assays$RNA@var.features, vmh@assays$SCT@var.features
)

# compare RNA and SCT assays for batch effects
DefaultAssay(vmh) <- "RNA"
vmh <- scale_data(vmh, genes = var_genes, groups = "Sample")
vmh <- RunPCA(vmh, npcs = 100)
vmh@reductions$pca@misc$sig_pcs <- knee_test(vmh)
vmh <- RunUMAP(vmh, dims = 1:vmh@reductions$pca@misc$sig_pcs)

umap_object <- vmh[["umap"]]
pca_object <- vmh[["pca"]]

# compare RNA and SCT assays for batch effects
DefaultAssay(vmh) <- "SCT"
vmh <- RunPCA(vmh, npcs = 100)
vmh@reductions$pca@misc$sig_pcs <- knee_test(vmh)
vmh <- RunUMAP(vmh, dims = 1:vmh@reductions$pca@misc$sig_pcs)

gc()
```

Results: Using `r length(neurons@assays$RNA@var.features)` variable genes from `Seurat` found `r length(neurons@assays$SCT@var.features)` from `sctransform`.  The `Seurat` variable features resulted in `r pca_object@misc$sig_pcs` PCs, and the `sctransform` variable genes resulted in `r neurons@reductions$pca@misc$sig_pcs` PCs.

```{r, fig.width = 7, fig.height = 3.2}
plot_umap_samples <- function(umap) {
  df <- bind_cols(as.data.frame(umap), vmh$Sample)
  ggplot(df, aes(x = UMAP_1, y = UMAP_2, color = `...3`)) +
    geom_point(stroke = 0, size = 1) +
    scale_color_manual(values = vmh@misc$sample_colors, name = NULL) +
    theme_void() +
    theme(legend.text = element_text(size = 7),
          plot.title = element_text(size = 10, hjust = 0.5))
}

cowplot::plot_grid(plotlist = list(
  plot_umap_samples(umap_object@cell.embeddings) + ggtitle("RNA"),
  plot_umap_samples(vmh@reductions$umap@cell.embeddings) + ggtitle("SCT")
))
```

The **RNA** assay looks better, cells are more "clumped", even across samples, making it more likely to find clusters.

```{r, include = FALSE}
DefaultAssay(vmh) <- "RNA"
vmh[["pca"]] <- pca_object
vmh[["umap"]] <- umap_object
rm(umap_object, pca_object)
gc()
```


\pagebreak

# Clustering VMH neurons

To cluster, I'll start with standard Louvain clustering from the kNN graph. With `k` set at 20, I'll vary the `resolution` parameter to optimize mean silhouette width.

```{r}
resolutions <- seq(0.2, 2, by = 0.2)
print(paste("Finding clusters for resolutions", paste(resolutions, collapse = ", "), "..."))
```

```{r, include = FALSE}
sig_pcs <- vmh@reductions$pca@misc$sig_pcs
vmh <- FindNeighbors(vmh, dims = 1:sig_pcs)

clusters <- map_dfc(
  resolutions,
  ~ FindClusters(vmh, resolution = .x)@active.ident
)
gc()
# get dissimilarity matrix
distances <- cluster::daisy(
  vmh@reductions$pca@cell.embeddings[, 1:sig_pcs]
)
gc()

# calculate silhouette width for each clustering
mean_widths <- apply(clusters, 2, function(x) {
  silhouette_object <- cluster::silhouette(as.numeric(x), distances)
  summary(silhouette_object)[["avg.width"]]
})

# choose best resolution based on max mean silhoutte width
best_resolution <- resolutions[mean_widths == max(mean_widths)]

# add clustering to official ident slot
vmh@active.ident <- clusters[, resolutions == best_resolution][[1]]

# remove unnecessary object
rm(resolutions, clusters, distances, mean_widths); gc()
```

Using resolution `r best_resolution`, there are `r length(unique(vmh@active.ident))` populations.

# VMH neuron markers
I'll now order the clusters based on similarity, using variable genes.

```{r}
vmh@misc$cellex <- cellex(
  as.data.frame(as.matrix(vmh@assays$RNA@counts)),
  vmh@active.ident
)
vmh@misc$cellex <- vmh@misc$cellex[, levels(vmh@active.ident)]

cluster_order <- order_clusters(vmh, rownames(vmh@misc$cellex))

vmh@active.ident <- factor(
  vmh@active.ident,
  levels = cluster_order,
  labels = 1:length(cluster_order)
)
vmh@misc$cellex <- vmh@misc$cellex[, cluster_order]
colnames(vmh@misc$cellex) <- 1:length(cluster_order)
```

## Putting clusters into classes
Using `CELLEX` to determine the expression overlap of clusters and finding the maximum number of clusters that leaves the clusters uncorrelated. These are presumably the larger "classes".

```{r}
# make hierarchical tree of distances between clusters
scaled_cluster <- sapply(levels(vmh@active.ident), function(x) {
  rowMeans(vmh@assays$RNA@scale.data[
    rownames(vmh@misc$cellex), vmh@active.ident == x
  ])
})
scaled_cluster <- scaled_cluster[
  apply(scaled_cluster, 1, function(x) !any(is.na(x))),
]

pca_cluster <- sapply(levels(vmh@active.ident), function(x) {
  colMeans(vmh@reductions$pca@cell.embeddings[
    vmh@active.ident == x, 1:sig_pcs
  ])
})
correlation <- cor(pca_cluster)
tree <- hclust(dist(correlation))

correlation <- cor(scaled_cluster)
tree <- hclust(dist(correlation))
vmh@misc$tree <- tree

vmh <- scale_data(vmh, groups = "Sample")
cut_tree <- function() {
  tree_levels <- 2:length(unique(vmh@active.ident))
  cor_fn <- function(n) {
    new_levels <- cutree(tree, n)
    new_clusters <- recode(vmh@active.ident, !!!new_levels)
    names(new_clusters) <- names(vmh@active.ident)
    cellex_genes <- cellex(
      as.data.frame(as.matrix(vmh@assays$RNA@counts)),
      new_clusters
    )
    # calculate correlation
    srt <- vmh
    srt@active.ident <- factor(new_clusters)
    correlations <- cor(
      cluster_means(srt, rownames(cellex_genes), data = "scale.data")
    )
    max_cor <- apply(correlations, 1, function(x) {
      sort(x, decreasing = TRUE)[2]
      })
    return(median(max_cor))
  }
  result <- map_dbl(tree_levels, cor_fn)
  return(result)
}

tree_levels <- cut_tree()
```

```{r, fig.width = 2, fig.height = 2}
tree_levels <- data.frame(
  "clusters" = 2:length(unique(vmh@active.ident)),
  "corr" = tree_levels
)
vmh@misc$tree_levels <- tree_levels
ggplot(vmh@misc$tree_levels, aes(x = clusters, y = corr)) +
  geom_hline(aes(yintercept = 0), color = "gray20") +
  geom_line() +
  geom_point(aes(color = corr), size = 4, show.legend = FALSE) +
  geom_text(aes(label = clusters), show.legend = FALSE, size = 2.5) +
  scale_color_gradient2() +
  xlab("Number of clusters") +
  ylab("Median top correlation") +
  theme_classic() +
  theme(axis.text = element_text(color = "black", size = 8),
        axis.title = element_text(size = 9))
```

6 clusters seems to be about the "sweet spot" that separates the cells into a relevant amount of uncorrelated clusters.

```{r}
vmh$VMH_cluster <- vmh@active.ident
new_clusters <- cutree(vmh@misc$tree, 6)
vmh$Class <- recode(vmh@active.ident, !!!new_clusters)
```

```{r}
print("Finding markers for new classes ...")
vmh@misc$class_markers <- cellex(
  as.data.frame(as.matrix(vmh@assays$RNA@counts)),
  vmh$Class
)
```

```{r}
cluster_names <- c(
  `1` = "Dlk1_1",
  `2` = "Dlk1_2",
  `3` = "Esr1_1",
  `4` = "Esr1_2",
  `5` = "Esr1_3",
  `6` = "Esr1_4",
  `7` = "Nfib_1",
  `8` = "Nfib_2",
  `9` = "Nfib_3",
  `10` = "Foxp2_1",
  `11` = "Foxp2_2",
  `12` = "Foxp2_3",
  `13` = "Fezf1_1",
  `14` = "Fezf1_2",
  `15` = "Fezf1_3",
  `16` = "Lepr_1",
  `17` = "Lepr_2",
  `18` = "Lepr_3",
  `19` = "Lepr_4",
  `20` = "Lepr_5",
  `21` = "Lepr_6",
  `22` = "Lepr_7",
  `23` = "Lepr_8",
  `24` = "Lepr_9"
)

vmh@active.ident <- recode(vmh@active.ident, !!!cluster_names)
vmh@active.ident <- factor(vmh@active.ident, levels = cluster_names)
```

### Comparing 6 and `r length(unique(vmh@active.ident))` clusters
```{r}
sig_pcs <- vmh[["pca"]]@misc$sig_pcs
distances <- cluster::daisy(vmh[["pca"]]@cell.embeddings[, 1:sig_pcs])
all_clusters <- cluster::silhouette(as.numeric(vmh@active.ident), distances)


all_classes <- cluster::silhouette(as.numeric(vmh$Class), distances)

data.frame(
  "Cluster" = vmh@active.ident,
  "Width" = all_classes[, 3],
  "Cell" = Cells(vmh),
  "Class" = vmh$Class
) %>%
  arrange(Class, desc(Width)) %>%
  mutate(Cell = factor(Cell, levels = Cell)) %>%
  ggplot(aes(x = Width, y = fct_rev(Cell))) +
    geom_col(aes(fill = Cluster)) +
    scale_fill_manual(values = vmh@misc$cluster_colors)

cuts <- lapply(seq(6, 24, by = 6), function(x) cutree(vmh@misc$tree, x))
widths <- map_dfc(
  cuts,
  ~ cluster::silhouette(recode(vmh$VMH_cluster, !!!.x), distances)[,3]
)
colnames(widths) <- seq(6, 24, by = 6)

x_limits <- c(min(widths), max(widths))

plot_widths <- function(x) {
  df <- data.frame(
    "Cluster" = vmh@active.ident,
    "Width" = pull(widths, x),
    "Cell" = Cells(vmh),
    "Class" = vmh$Class
  ) %>%
    arrange(Class, desc(Width)) %>%
    mutate(Cell = factor(Cell, levels = Cell))
  avg <- mean(df$Width)
  positive <- sum(df$Width > 0)

  ggplot(df, aes(x = Width, y = fct_rev(Cell))) +
    geom_col(aes(fill = Cluster), show.legend = FALSE) +
    scale_fill_manual(values = vmh@misc$cluster_colors) +
    labs(title = paste(x, "classes"),
         subtitle = paste("Mean:", round(avg, 2), "\nCells above 0:", positive)) +
    theme_void() +
    scale_x_continuous(limits = x_limits) +
    theme(plot.title = element_text(hjust = 0.5, size = 10, face = "bold"),
          plot.subtitle = element_text(hjust = 0.5, size = 8))
}

cowplot::plot_grid(plotlist = map(colnames(widths), plot_widths), ncol = 4)
```

```{r}
# setting cluster colors
color_options <- map(
  names(wesanderson::wes_palettes),
  ~ as.character(wesanderson::wes_palette(.x))
) %>%
  unlist()

# only keep colors that aren't too light or dark
get_luminance <- function(color) {
  col <- col2rgb(color)
  0.2126*col["red", ] + 0.7152*col["green", ] + 0.0722*col["blue" ,]
}

# cluster similar colors for each class
color_options <- color_options[
  get_luminance(color_options) > 80 & get_luminance(color_options) < 200
]
rgb_space <- col2rgb(color_options)
color_clusters <- kmeans(t(rgb_space), length(unique(vmh$Class)))

# select
color_cluster_table <- table(color_clusters$cluster) %>%
  sort(decreasing = TRUE) %>%
  names()
cluster_table <- table(vmh@active.ident) %>%
  names() %>%
  str_extract(".+(?<=_)") %>%
  table() %>%
  sort(decreasing = TRUE)

# pick colors
cluster_colors <- character(0)
for (i in 1:length(cluster_table)) {
  new_colors <- color_options[color_clusters$cluster == i][1:cluster_table[i]]
  cluster_colors <- c(cluster_colors, new_colors)
}
names(cluster_colors) <- sapply(
  1:length(cluster_table), function(x) {
    paste0(names(cluster_table)[x], seq(cluster_table[x]))
  }) %>% unlist()

DimPlot(vmh, label = TRUE) + scale_color_manual(values = cluster_colors)

vmh@misc$cluster_colors <- cluster_colors
```

---

Saving the `vmh` object as `vmh.rds`

```{r}
saveRDS(vmh, "vmh.rds")
```

```{r}
# co-clustering frequency
downsample_cluster <- function(object, freq = 0.8) {
  sig_pcs <- object@reductions$pca@misc$sig_pcs
  cells <- sample(Cells(object), round(freq*ncol(object), 0))
  srt <- subset(object, cells = cells)
  srt <- FindNeighbors(srt, dims = 1:sig_pcs, verbose = FALSE)
  resolutions <- seq(0.2, 2, by = 0.2)
  clusters <- map_dfc(
    resolutions,
    ~ setNames(data.frame(
        FindClusters(srt, resolution = .x, verbose = FALSE)@active.ident
      ), paste0("res", .x))
  )
  # get dissimilarity matrix
  distances <- cluster::daisy(
    srt@reductions$pca@cell.embeddings[cells, 1:sig_pcs]
  )
  # calculate silhouette width for each clustering
  mean_widths <- apply(clusters, 2, function(x) {
    silhouette_object <- cluster::silhouette(as.numeric(x), distances)
    summary(silhouette_object)[["avg.width"]]
  })
  # choose best resolution based on max mean silhoutte width
  best_resolution <- resolutions[mean_widths == max(mean_widths)]
  gc()
  best_clusters <- clusters[, resolutions == best_resolution]
  names(best_clusters) <- cells
  # return clusters
  return(best_clusters)
}

cocluster <- pbapply::pbreplicate(100, downsample_cluster(vmh), simplify = FALSE)
```

```{r}
# find coclustering frequency for each pair of cells
get_freq <- function(cell1, cell2) {
  common_subsets = sapply(cocluster, function(x) {
    if (cell1 %in% names(x) & cell2 %in% names(x)) x[cell1] == x[cell2]
  })
  common_subsets <- common_subsets[[!is.null(common_subsets)]] %>% unlist()
  sum(common_subsets)/length(common_subsets)
}

# set up data.frame of all cells in each column, removing duplicates
test_cells <- sample(Cells(vmh), 1000)
cell_matrix <- expand.grid(test_cells, test_cells)
cell_matrix <- filter(cell_matrix, Var1 != Var2)
cell_matrix <- cell_matrix[!duplicated(t(apply(cell_matrix, 1, sort))), ]

# get frequency for each unique pair of cells
cell_matrix$Freq <- pbapply::pbapply(cell_matrix, 1, function(x) {
  get_freq(x["Var1"], x["Var2"])
})
cell_matrix <- cell_matrix %>%
  mutate_at(vars(Var1, Var2), factor, levels = names(sort(vmh@active.ident)))

ggplot(filter(cell_matrix, !is.na(Freq)),
       aes(x = Var1, y = Var2, fill = Freq)) +
  geom_tile() +
  scale_fill_gradient() +
  theme_void() +
  scale_x_discrete(drop = TRUE) +
  scale_y_discrete(drop = TRUE)
```

\pagebreak

# Top markers
Running `CELLEX` to identify the top marker genes for each cluster

```{r}
# CELLEX for the final 20 clusters
print("Running CELLEX ...")
cellex_genes <- cellex(
  as.data.frame(as.matrix(vmh@assays$RNA@counts)),
  vmh@active.ident
)

# reorder to match cluster levels
cellex_genes <- cellex_genes[, levels(vmh@active.ident)]
```

```{r}
# select top genes by the best 3 for each cluster
top_genes <- apply(cellex_genes, 2, function(x) {
  rownames(cellex_genes)[which(x >= sort(x, decreasing = TRUE)[3])]
}) %>% as.vector()
top_genes <- top_genes[!duplicated(top_genes)]
```

```{r, fig.height = 3.05, fig.width = 4.9}
cellex_genes[top_genes, ] %>%
  rownames_to_column("gene") %>%
  gather(-gene, key = "cluster", value = "ESmu") %>%
  filter(ESmu > 0) %>%
  mutate(gene = factor(gene, levels = top_genes),
         cluster = factor(cluster, levels = levels(vmh@active.ident))) %>%
  ggplot(aes(x = fct_rev(cluster), y = gene, color = ESmu)) +
  geom_point(size = 1) +
  scale_color_gradient(low = "gray90", high = "navyblue", name = "ES",
                      breaks = seq(0, 1, by = 0.2),
                      labels = seq(0, 1, by = 0.2)) +
  coord_flip() +
  theme_void() +
  theme(axis.text.x = element_text(color = "black", angle = 90,
                                   hjust = 1, vjust = 0.5, size = 6),
        axis.text.y = element_text(size = 9, hjust = 1),
        legend.position = "top",
        legend.direction = "horizontal",
        legend.key.width = unit(0.2, "in"),
        legend.key.height = unit(0.02, "in"),
        legend.title = element_text(size = 8),
        legend.text = element_text(size = 7),
        panel.grid.major = element_line(color = "gray90"))

ggsave("../../figures/panels/2e.png", width = 4.9, height = 3.05,
       units = "in", dpi = 400)
```

\pagebreak

# TRAP comparison
Comparing data to TRAP-seq of *LepRb* VMH genetic populations.

```{r, fig.width = 2.2, fig.height = 2.2}
file <- "../../../TRAP-seq/VMH_Slc17a6+Lepr/results.csv"
lepr <- read_csv("../../../TRAP-seq/VMH_Slc17a6+Lepr/results.csv")
```

There are `r sum(lepr$Enrichment > 0 & lepr$P < 0.05, na.rm = TRUE)` genes enriched in the *Slc17a6*+*Lepr* TRAP-seq.

```{r}
ggplot(lepr, aes(x = Bead, y = Enrichment, color = P < 0.05)) +
  geom_hline(aes(yintercept = 0)) +
  geom_point(stroke = 0, alpha = 0.3, show.legend = FALSE) +
  scale_color_manual(values = c("gray", "red4"),
                     name = "P < 0.05") +
  scale_x_continuous(trans = "log2", expand = c(0, 0), limits = c(1, NA)) +
  scale_y_continuous(expand = c(0, 0), limits = c(0, NA)) +
  theme_classic() +
  xlab("Expression (CPM)") +
  ylab(expression("Enrichment (log"[2]*")")) +
  annotate("label", x = 2, y = 5, label = "P < 0.05", color = "red4",
           hjust = 0, size = 3)
```

I'll use these enriched genes to create a TRAP-seq score for every cell using PCA in the same way I did for the VMH as a whole. In this case, I'll use a Bead CPM of at least 1 and enrichment of at least log2(2).

```{r, fig.width = 4.2, fig.height = 2.2}
lepr_genes <- filter(lepr, Bead > 10 & Enrichment > log2(1) & P < 0.05)$Gene
# only keep genes that are in the scale.data slot and not NA
lepr_genes <- lepr_genes[lepr_genes %in% rownames(vmh[["RNA"]]@scale.data)[
  apply(vmh[["RNA"]]@scale.data, 1, function(x) !any(is.na(x)))
]]
```

```{r}
# calculate score
lepr_score <- eigengene(vmh, lepr_genes)
vmh$Lepr <- lepr_score
```

```{r, fig.width = 4.2, fig.height = 2.2}
plot_settings <- list(
  geom_point(stroke = 0, size = 0.4),
  theme_void(),
  theme(legend.position = "top", legend.direction = "horizontal",
        legend.key.height = unit(0.03, "in"),
        legend.title = element_text(size = 8))
)
cowplot::plot_grid(plotlist = list(
  data.frame(
  "UMAP1" = vmh@reductions$umap@cell.embeddings[,1],
  "UMAP2" = vmh@reductions$umap@cell.embeddings[,2],
  "score" = vmh@assays$RNA@data["Lepr", ]
) %>%
  ggplot(aes(x = UMAP1, y = UMAP2, color = score)) +
  geom_point(stroke = 0) +
  scale_color_gradient(name = expression(italic("Lepr")),
                       low = "gray90", high = "navyblue") +
  plot_settings,
  data.frame(
    "UMAP1" = vmh@reductions$umap@cell.embeddings[,1],
    "UMAP2" = vmh@reductions$umap@cell.embeddings[,2],
    "score" = lepr_score
  ) %>%
  ggplot(aes(x = UMAP1, y = UMAP2, color = score)) +
    scale_color_gradient2(name = "TRAP\nloading",
                        high = "navyblue", low = "red4") +
    plot_settings
))
```

\pagebreak

# VMH *Lepr* pseudo-TRAP

```{r}
lepr_clusters <- levels(vmh@active.ident)[
  str_detect(levels(vmh@active.ident), "Lepr")
]
```

To see how well the TRAP corresponds to the snRNA-seq, I'll make a pseudo-bulk dataset from the snRNA-seq by Sample to perform "pseudo-TRAP" on the presumptive VMH *Lepr* populations (`r paste(lepr_clusters, collapse = ", ")`) vs. the non-VMH *Lepr* populations (including glia).

```{r}
print("Running pseudo-TRAP with DESeq2 ...")
```

```{r, include = FALSE}
# stashing VMH cluster IDs and loading full dataset
vmh_clusters <- vmh@active.ident
srt <- readRDS("mouse.rds")
mtx <- srt@assays$RNA@counts

# make pseudo TRAP from the snRNA-seq
metadata <- data.frame(
  "Cells" = rep(c("Bead", "Sup"), length(unique(srt$Sample))),
  "Sample" = rep(unique(srt$Sample), each = 2)
)
bead_cells <- names(vmh_clusters)[vmh_clusters %in% lepr_clusters]
sup_cells <- union(
  Cells(srt)[!Cells(srt) %in% names(vmh_clusters)],
  names(vmh_clusters)[!vmh_clusters %in% lepr_clusters]
)
counts <- apply(metadata, 1, function(x) {
  tx_cells <- switch(
    as.character(x["Cells"][[1]]), "Bead" = bead_cells, "Sup" = sup_cells
  )
  sample_cells <- Cells(srt)[srt$Sample == x["Sample"]]
  Matrix::rowSums(mtx[, intersect(tx_cells, sample_cells)])
})

rm(srt); gc()

# run DESeq2 to detect enriched genes
dds <- DESeq2::DESeqDataSetFromMatrix(
  counts, metadata, ~ Sample + Cells
  ) %>%
  DESeq2::DESeq()
pseudo_trap <- DESeq2::results(dds, contrast = c("Cells", "Bead", "Sup"))
pseudo_trap <- as.data.frame(pseudo_trap) %>% rownames_to_column("Gene")
cpm <- DESeq2::fpm(dds)
cpm_cells <- map_dfc(c("Bead", "Sup"), ~ rowMeans(cpm[, metadata$Cells == .x])) %>%
  set_names(c("Bead", "Sup"))
cpm_cells$Gene <- rownames(cpm)
pseudo_trap <- inner_join(cpm_cells, pseudo_trap, by = "Gene") %>%
  select(Gene, Bead, Sup, log2FoldChange, padj) %>%
  rename("Enrichment" = log2FoldChange, "P" = padj)

write.csv(pseudo_trap, "lepr_pseudo_trap.csv", row.names = FALSE, na = "")
```



## Top *Lepr* genes
Plotting the top genes that are in both the *Lepr* TRAP-seq and the *Lepr* populations in the single-cell.

```{r, fig.width = 4, fig.height = 2.4}
marker_genes <- c("Lepr", "Rai14", "Tnfrsf8", "Acvr1c", "Ccnjl", "Lamb3",
               "Nptx2", "Cmbl", "Cd36", "Grhl1", "Cbln1", "Rin1",
               "Sema3a", "Tgfbr3")

cowplot::plot_grid(plotlist = list(
  # left plot (single-cell)
  heatmap_plot(vmh, marker_genes,
               cluster_clusters = FALSE,
               cluster_genes = FALSE,
               draw_tree = FALSE,
               label_genes = TRUE) +
    theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5),
          axis.text.y = element_text(size = 9, hjust = 1),
          legend.direction = "horizontal", legend.position = "top",
          legend.key.height = unit(0.03, "in"),
          legend.title = element_text(size = 7),
          legend.text = element_text(size = 6)) +
    scale_fill_gradient2(name = "Scaled\nexpression") +
    annotate("rect", xmin = 9.5, xmax = 13.5, ymin = 0.5,
             ymax = length(marker_genes) + 0.5, fill = NA, color = "gray",
             size = 1.5),
  # right plot (TRAP)
  filter(lepr, Gene %in% marker_genes) %>%
    mutate(Gene = factor(Gene, levels = marker_genes)) %>%
    ggplot(aes(x = "TRAP\nenrichment", y = fct_rev(Gene),
               fill = Enrichment)) +
    geom_tile() +
    scale_fill_gradient(breaks = c(0, 1), labels = c(0, 1)) +
    theme_void() +
    theme(legend.direction = "horizontal", legend.position = "top",
          axis.text.x = element_text(color = "black", angle = 90, size = 8,
                                     hjust = 1),
          legend.key.height = unit(0.03, "in"),
          legend.key.width = unit(0.08, "in"),
          legend.text = element_text(size = 6)) +
    scale_fill_gradient2(name = "")
), rel_widths = c(0.92, 0.08))

ggsave("../../figures/panels/3f.png", width = 4, height = 2.4,
       units = "in", dpi = 400)

```
\pagebreak

# Files

Saving VMH Seurat object as `mouse_vmh.rds`

```{r}
saveRDS(vmh, "mouse_vmh.rds", compress = TRUE)
```

\pagebreak

# Session info
```{r session-info}
sessionInfo()
```
